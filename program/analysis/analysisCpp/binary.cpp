#include "pch.h"
#include <vector>
#include <cstdint>
#include <immintrin.h>

struct BitmapRef {
    uint8_t* data;
    int num_bytes;
    int bytes_per_row;

    BitmapRef(uint8_t* data_ptr, int num_rods) : data(data_ptr) {
        num_bytes = num_rods * num_rods / 8;
        bytes_per_row = num_rods / 8;
    }

    // Set individual bit value to 1
    void set(int i, int j) {
        int pos = i * bytes_per_row * 8 + j;
        int byte_idx = pos / 8;
        data[byte_idx] |= (uint8_t)1 << (pos % 8);
    }
};

// Convert delaunay indices to bitmap
void bitmap_from_delaunay(int num_edges, int num_rods, void* indices_ptr, void* edges_ptr, void* dst_ptr) {
    BitmapRef dst = BitmapRef((uint8_t*)dst_ptr, num_rods);
    int* indices = (int*)indices_ptr;
    int* edges = (int*)edges_ptr;
    
    int id1 = 0;
    for (int j = 0; j < num_edges; j++) {
        while (j == *indices && id1 < num_rods) {
            indices++;
            id1++;
        }
        int id2 = edges[j];
        dst.set(id1, id2); dst.set(id2, id1);
    }
}

// SIMD-accelerated vector subtraction: a - b (1-1=0, 1-0=1, 0-0=0, 0-1=0)
void bitmap_subtract(void* a_ptr, void* b_ptr, void* dst_ptr, int num_bytes) {
    uint8_t* a = static_cast<uint8_t*>(a_ptr);
    uint8_t* b = static_cast<uint8_t*>(b_ptr);
    uint8_t* dst = static_cast<uint8_t*>(dst_ptr);

    // Process 32 bytes (256 bits) per iteration
    for (size_t i = 0; i < num_bytes; i += 32) {
        // Load 256-bit chunks
        __m256i a_vec = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(a + i));
        __m256i b_vec = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(b + i));

        // Compute a & ~b using AVX2 (rule: 1-1=0, 1-0=1, 0-0=0, 0-1=0)
        __m256i res = _mm256_andnot_si256(b_vec, a_vec);

        // Store result
        _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst + i), res);
    }
}

int bitmap_count(void* data_ptr, int num_bytes) {
    // 256-bit lookup table
    // Generated by python code: str([bin(x).count('1') for x in range(256)])
    constexpr int nibble_lookup[256] = {
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
    };

    uint8_t* data = static_cast<uint8_t*>(data_ptr);
    int total = 0;
    for (int i = 0; i < num_bytes; i++) {
        total += nibble_lookup[data[i]];
    }
    return total;
}

int bitmap_to_pairs(void* src_ptr, void* dst_ptr, int num_rods) {
    BitmapRef src = BitmapRef((uint8_t*)src_ptr, num_rods);
    std::pair<int, int>* dst = static_cast<std::pair<int, int>*>(dst_ptr);
    std::pair<int, int>* moving_dst = static_cast<std::pair<int, int>*>(dst_ptr);
    
    for (int i = 0; i < src.num_bytes; i++) {
        int id1 = i / src.bytes_per_row;
        for (int j = 0; j < 8; j++) {
            if (src.data[i] & (1 << j)) {
                int id2 = j + (i % src.bytes_per_row) * 8;
                if (id1 < id2) *moving_dst++ = { id1, id2 };
            }
        }
    }
    return moving_dst - dst;
}