import os
from threading import Thread

import numpy as np

import default
from h5tools.h5tools import stack_h5_datasets
from h5tools.utils import dict_to_numpy_struct, randomString
from . import boundary, potential as pot, utils as ut
from .simulator import createSimulator
from .state import State


class Ensemble:
    def __init__(self, n: int, d: float, potential: pot.PotentialBase):
        self.n, self.d = n, d
        self.id = randomString()
        self.simulators = []
        self.potential = potential
        self.dataset = None

    def setSimulationProperties(self, N, phi0, Gamma0, compress_func_A, compress_func_B):
        self.kwargs = {
            'N': N, 'n': self.n, 'd': self.d, 'phi0': phi0, 'Gamma0': Gamma0,
            'compress_func_A': compress_func_A, 'compress_func_B': compress_func_B,
        }
        return self

    @property
    def metadata(self) -> np.ndarray:
        return dict_to_numpy_struct(self.potential.tag, 32)

    def addSimulator(self):
        """
        This method cannot be called in parallel!
        """
        Id = f"{self.id}_{len(self.simulators)}"
        simulator = createSimulator(Id, **self.kwargs)
        simulator.setPotential(self.potential)
        self.simulators.append(simulator)

    def setReplica(self, n_replica: int):
        for i in range(n_replica):
            self.addSimulator()
        return self

    def init(self):
        self.potential.cal_potential(threads=len(self.simulators))

    def pack(self):
        stack_h5_datasets(self.id)
        # delete old files
        # for i in range(len(self.simulators)):
        #     os.remove(f"{self.id}_{i}.h5")

    def execute(self):
        self.init()
        self.threads = []
        for s in self.simulators:
            thread = Thread(target=s.execute)
            self.threads.append(thread)
            thread.start()
        for thread in self.threads:
            thread.join()
        self.pack()


def CreateEnsemble(N, n, d, phi0, Gamma0, compress_func_A, compress_func_B, potential):
    return Ensemble(n, d, potential).setSimulationProperties(
        N, phi0, Gamma0, compress_func_A, compress_func_B
    )


def get_uniform_compress_delta(ratio, N, n, d, phi0, Gamma0):
    gamma = 1 + (n - 1) * d / 2
    B = np.sqrt(N * (np.pi + 4 * (gamma - 1)) / (np.pi * Gamma0 * phi0)) / gamma
    A = Gamma0 * B
    return ratio * A, ratio * B


def StartEnsemble(replica: int, N: int, n: int, d: float, phi0: float, Gamma0: float):
    from recipe import InitRecipe
    InitRecipe()
    radial_func = pot.PowerFunc(2.5)
    potential = pot.RodPotential(n, d, radial_func)

    if default.if_keep_boundary_aspect:
        da, db = get_uniform_compress_delta(default.uniform_compress_rate, N, n, d, phi0, Gamma0)
        compress_func_A = boundary.UniformCompress(da)
        compress_func_B = boundary.UniformCompress(db)
    else:
        compress_func_A = boundary.NoCompress()
        compress_func_B = boundary.RatioCompress(default.compress_rate)

    ensemble = CreateEnsemble(N, n, d, phi0, Gamma0, compress_func_A, compress_func_B, potential)
    ensemble.setReplica(replica)
    ensemble.execute()


def SetRelaxationRecipe(*lst):
    """
    :param lst: list of functions, generated by relaxation.Relaxation
    """
    ut.add_dynamic_methods(State, lst, 'relaxation')
