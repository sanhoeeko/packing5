import os
from threading import Thread

import numpy as np

import default
from h5tools.h5tools import stack_h5_datasets
from h5tools.utils import dict_to_numpy_struct, randomString
from . import boundary, potential as pot, utils as ut
from .simulator import createSimulator
from .state import State


class Ensemble:
    def __init__(self, n: int, d: float, potential: pot.PotentialBase):
        self.n, self.d = n, d
        self.id = randomString()
        self.simulators = []
        self.potential = potential
        self.dataset = None

    def setSimulationProperties(self, N, phi0, Gamma0, compress_func_A, compress_func_B):
        self.kwargs = {
            'N': N, 'n': self.n, 'd': self.d, 'phi0': phi0, 'Gamma0': Gamma0,
            'compress_func_A': compress_func_A, 'compress_func_B': compress_func_B,
        }
        return self

    @property
    def metadata(self) -> np.ndarray:
        return dict_to_numpy_struct(self.potential.tag, 32)

    def addSimulator(self):
        """
        This method cannot be called in parallel!
        """
        Id = f"{self.id}_{len(self.simulators)}"
        simulator = createSimulator(Id, **self.kwargs)
        simulator.setPotential(self.potential)
        self.simulators.append(simulator)

    def setReplica(self, n_replica: int):
        for i in range(n_replica):
            self.addSimulator()
        return self

    def init(self):
        self.potential.cal_potential(threads=len(self.simulators))

    def pack(self):
        stack_h5_datasets(self.id)
        # delete old files
        for i in range(len(self.simulators)):
            os.remove(f"{self.id}_{i}.h5")

    def execute(self):
        self.init()
        self.threads = []
        for s in self.simulators:
            thread = Thread(target=s.execute)
            self.threads.append(thread)
            thread.start()
        for thread in self.threads:
            thread.join()
        self.pack()


def CreateEnsemble(N, n, d, phi0, Gamma0, compress_func_A, compress_func_B, potential):
    return Ensemble(n, d, potential).setSimulationProperties(
        N, phi0, Gamma0, compress_func_A, compress_func_B
    )


def StartEnsemble(replica: int, N: int, n: int, d: float, phi0: float, Gamma0: float):
    radial_func = pot.PowerFunc(2.5)
    potential = pot.RodPotential(n, d, radial_func)
    compress_func_A = boundary.NoCompress()
    compress_func_B = boundary.RatioCompress(default.compress_rate)
    ensemble = CreateEnsemble(int(N), int(n), float(d), float(phi0), float(Gamma0),
                              compress_func_A, compress_func_B, radial_func)
    ensemble.setReplica(int(replica))
    ensemble.execute()


def SetRelaxationRecipe(*lst):
    """
    :param lst: list of functions, generated by relaxation.Relaxation
    """
    ut.add_dynamic_methods(State, lst, 'relaxation')
